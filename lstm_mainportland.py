# -*- coding: utf-8 -*-
"""lstm_PO_Murders2016_2022.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13xdGa_nd142h724LS2MWTnNhiJW8zdkU
"""

import tensorflow as tf
import os
import pandas as pd
import numpy as np

!cp /content/drive/MyDrive/Colab\ Notebooks/ePredictor/preprocess.py /content

import preprocess
df=preprocess.getfile()

df.index = pd.to_datetime(df['Months'], format='%d/%m/%Y')
df[:24]

temp = df['Homicide Offenses']
temp.plot() #grab Homicide Offenses

def df_to_X_y(df, window_size=12):
 df_as_np = df.to_numpy()
 X =[]
 y =[]
 for i in range(len(df_as_np)-window_size):
  row = [[a] for a in df_as_np[i:i+12]]
  X.append(row)
  label = df_as_np[i+12]
  y.append(label)
 return np.array(X), np.array(y)

window_size =12
X, y = df_to_X_y(temp, window_size)
X.shape, y.shape

X_train, y_train = X[:60], y[:60]
X_val, y_val = X[48:60], y[48:60]
X_test, y_test = X[60:], y[60:]
X_train.shape, y_train.shape, X_val.shape, y_val.shape, X_test.shape, y_test.shape

from keras.models import Sequential
from keras.layers import *
from keras.callbacks import ModelCheckpoint
from keras.losses import MeanSquaredError
from keras.metrics import RootMeanSquaredError
from keras.optimizers import Adam

model1 =Sequential()
model1.add(InputLayer((12, 1)))
model1.add(LSTM(64))
model1.add(Dense(8, 'relu'))
model1.add(Dense(1, 'linear')) #result linear

model1.summary()

cp = ModelCheckpoint('model1/', save_best_only=True)
model1.compile(loss=MeanSquaredError(), metrics = [RootMeanSquaredError()])

model1.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=300,  verbose = 0, callbacks = [cp])

from keras.models import load_model
model1 = load_model('model1/') #loads one with lowest value into memory

train_predictions = model1.predict(X_train).flatten()
train_results = pd.DataFrame(data={'Train Predictions':train_predictions, 'Actuals':y_train})
train_results

import matplotlib.pyplot as plt
plt.plot(train_results['Train Predictions'])
plt.plot(train_results['Actuals'])

val_predictions = model1.predict(X_train).flatten()
val_results = pd.DataFrame(data={'Val Predictions':val_predictions, 'Actuals':y_train})
val_results

plt.plot(val_results['Val Predictions'])
plt.plot(val_results['Actuals'])

val_predictions = model1.predict(X_val).flatten()
val_results = pd.DataFrame(data={'Val Predictions':val_predictions, 'Actuals':y_val})
val_results

plt.plot(val_results['Val Predictions'])
plt.plot(val_results['Actuals'])

test_predictions = model1.predict(X_test).flatten()
test_results = pd.DataFrame(data={'Test Predictions':test_predictions, 'Actuals':y_test})
test_results

plt.plot(test_results['Test Predictions'])
plt.plot(test_results['Actuals'])

forecast_errors = [y_test[i]-test_predictions[i] for i in range(len(y_test))]
print('Forecast Errors: %s' % forecast_errors)

mean_forecast_error = sum(forecast_errors)/12
print('Mean_Forecast_Error: %f' % mean_forecast_error)

from sklearn.metrics import mean_absolute_error
mae = mean_absolute_error(y_test, test_predictions)
print('MAE: %f' % mae)

from sklearn.metrics import mean_squared_error
mse = mean_squared_error(y_test, test_predictions)
print('MSE: %f' % mse)

from sklearn.metrics import mean_squared_error
from math import sqrt
mse = mean_squared_error(y_test, test_predictions)
rmse = sqrt(mse)
print('RMSE: %f' % rmse)

from sklearn.metrics import mean_absolute_percentage_error
mape = mean_absolute_percentage_error(y_test, test_predictions)
print('MAPE: %f' % mape)